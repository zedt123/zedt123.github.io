<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Andreas Makris">
<meta name="dcterms.date" content="2024-12-15">
<meta name="description" content="An introduction to the two formulations of Diffusion models and their relationship.">

<title>DDPM connection to SDEs – Andreas Makris</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../am.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../am.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Andreas Makris</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/andreas-makris-41868b225/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/zedt123"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">DDPM connection to SDEs</h1>
                  <div>
        <div class="description">
          An introduction to the two formulations of Diffusion models and their relationship.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">diffusion</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Andreas Makris </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 15, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ddpm-connection-to-sdes" id="toc-ddpm-connection-to-sdes" class="nav-link active" data-scroll-target="#ddpm-connection-to-sdes">DDPM connection to SDEs</a>
  <ul class="collapse">
  <li><a href="#diffusion-models-with-discrete-markov-chains-ddpms" id="toc-diffusion-models-with-discrete-markov-chains-ddpms" class="nav-link" data-scroll-target="#diffusion-models-with-discrete-markov-chains-ddpms">Diffusion Models with Discrete Markov Chains (DDPMs)</a></li>
  <li><a href="#diffusion-using-stochastic-differential-equations-sdes" id="toc-diffusion-using-stochastic-differential-equations-sdes" class="nav-link" data-scroll-target="#diffusion-using-stochastic-differential-equations-sdes">Diffusion Using Stochastic Differential Equations (SDEs)</a></li>
  <li><a href="#understanding-sdes" id="toc-understanding-sdes" class="nav-link" data-scroll-target="#understanding-sdes">Understanding SDEs</a></li>
  <li><a href="#showing-the-equivalence" id="toc-showing-the-equivalence" class="nav-link" data-scroll-target="#showing-the-equivalence">Showing the equivalence</a>
  <ul class="collapse">
  <li><a href="#equivalence-of-forward-processes" id="toc-equivalence-of-forward-processes" class="nav-link" data-scroll-target="#equivalence-of-forward-processes">Equivalence of Forward Processes</a></li>
  <li><a href="#equivalence-of-reverse-processes" id="toc-equivalence-of-reverse-processes" class="nav-link" data-scroll-target="#equivalence-of-reverse-processes">Equivalence of Reverse Processes</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="sde_ddpm.png" class="img-fluid"></p>
<section id="ddpm-connection-to-sdes" class="level1">
<h1>DDPM connection to SDEs</h1>
<p>In the past few years, diffusion models <span class="citation" data-cites="ddpm sde_diff latent_diff sora">(<a href="#ref-ddpm" role="doc-biblioref">Ho, Jain, and Abbeel 2020</a>; <a href="#ref-sde_diff" role="doc-biblioref">Song et al. 2021</a>; <a href="#ref-latent_diff" role="doc-biblioref">Rombach et al. 2022</a>; <a href="#ref-sora" role="doc-biblioref">Brooks et al. 2024</a>)</span> have taken the machine learning community by storm, setting state-of-the-art results in image generation and other creative synthesis tasks. From a statistical view, these models are used to sample from a complex distribution (e.g., images of cats) by iteratively updating a simple distribution (e.g., isotropic Gaussian). However, these models often appear in two different flavors, which can be confusing for newcomers. One line of work defines diffusion models as a forward–backward Markov chain, where data is gradually corrupted by noise in a sequence of discrete steps and then recovered through a learned reverse diffusion process. Another line of research interprets the same idea through continuous stochastic processes described by Stochastic Differential Equations (SDEs), where data flows forward in time under a noising SDE and is restored by solving the corresponding time-reversed SDE. Although these two approaches may seem distinct at first glance, they are in fact closely related: the Markov chain formulation can be seen as a discretization of the continuous SDE framework. In this post, we’ll explore this connection and see how the discrete-time diffusion process converges to a continuous SDE in the limit of infinitely many small steps. First, let’s start by introducing the two definitions of diffusion models.</p>
<section id="diffusion-models-with-discrete-markov-chains-ddpms" class="level2">
<h2 class="anchored" data-anchor-id="diffusion-models-with-discrete-markov-chains-ddpms">Diffusion Models with Discrete Markov Chains (DDPMs)</h2>
<p>Diffusion models were popularized by Denoising Diffusion Probabilistic Models (DDPMs) <span class="citation" data-cites="ddpm">(<a href="#ref-ddpm" role="doc-biblioref">Ho, Jain, and Abbeel 2020</a>)</span>. The core idea is to start with a data distribution <span class="math inline">\(p(\boldsymbol{x}_0)\)</span> and define a forward diffusion process that gradually adds noise to the data over a finite sequence of time steps <span class="math inline">\((\boldsymbol{x}_0, \boldsymbol{x}_1, \ldots, \boldsymbol{x}_T)\)</span>. At each step, Gaussian noise is added according to a predefined schedule <span class="math inline">\(\{\beta_t\}_{t=1}^N\)</span>. This process transforms an original data sample <span class="math inline">\(\boldsymbol{x}_0\)</span> into a nearly pure noise sample <span class="math inline">\(\boldsymbol{x}_T\)</span>. Formally, the forward process is given by:</p>
<p><span class="math display">\[
\boldsymbol{x}_t = \sqrt{1 - \beta_t} \, \boldsymbol{x}_{t-1} + \sqrt{\beta_t} \, \boldsymbol{z}_{t-1}, \quad \boldsymbol{z}_{t-1} \sim \mathcal{N}(0, I), \quad t=1, \ldots, N
\]</span></p>
<p>A neural network <span class="math inline">\(\hat{\epsilon}(\boldsymbol{x}_{i}, i)\)</span> is then trained to approximate the noise added to reverse the process. That is, starting from noise <span class="math inline">\(\boldsymbol{x}_T \sim \mathcal{N}(0, I)\)</span>, we iteratively denoise it until we recover a sample <span class="math inline">\(\boldsymbol{x}_0 \sim p(\boldsymbol{x}_0)\)</span>. This reverse procedure is also a Markov chain, but its transition kernels are learned. Once trained, sampling from the model is done by reversing the diffusion process step-by-step:</p>
<p><span class="math display">\[
\boldsymbol{x}_t = \frac{1}{\sqrt{1 - \beta_t}} \left( \boldsymbol{x}_{t+1} - \frac{\beta_t}{\sqrt{1 - \bar{\alpha}_t}} \hat{\epsilon}(\boldsymbol{x}_{t+1}, t+1) \right) + \sqrt{\beta_t} \, \boldsymbol{z}_{t-1}
\]</span></p>
<p>where we have defined <span class="math inline">\(\bar{\alpha}_t := \prod_{s=1}^t \alpha_s\)</span>. A common choice of hyperparameters in this setting is:</p>
<p><span class="math display">\[
\begin{align*}
    N &amp;= 1000, \\
    \beta_1 &amp;= 10^{-4}, \\
    \beta_T &amp;= 0.02, \\
    \beta_t &amp;= \beta_{t-1} + \frac{\beta_N - \beta_1}{N}, \quad \text{for } t=2, \ldots, N-1  
\end{align*}
\]</span></p>
</section>
<section id="diffusion-using-stochastic-differential-equations-sdes" class="level2">
<h2 class="anchored" data-anchor-id="diffusion-using-stochastic-differential-equations-sdes">Diffusion Using Stochastic Differential Equations (SDEs)</h2>
<p>An alternative perspective on diffusion models comes from continuous-time formulations, where the noising process is described as a solution to a Stochastic Differential Equation (SDE) <span class="citation" data-cites="sde_diff">(<a href="#ref-sde_diff" role="doc-biblioref">Song et al. 2021</a>)</span>. Instead of a finite number of steps, we imagine a continuous time variable <span class="math inline">\(t \in [0,1]\)</span> that governs the diffusion of clean data into noise:</p>
<p><span class="math display">\[
d\boldsymbol{x} = \boldsymbol{f}(\boldsymbol{x}, t) \, dt + g(t) \, d\boldsymbol{w},
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{w}\)</span> is the standard Wiener process (a.k.a., Brownian motion). If we know the gradient of the distribution of the data with respect to the data (at each <span class="math inline">\(t\)</span>), i.e., <span class="math inline">\(\nabla_{\boldsymbol{x}} \log p_t(\boldsymbol{x})\)</span>, we can reverse this process:</p>
<p><span class="math display">\[
d\boldsymbol{x} = \left[ \boldsymbol{f}(\boldsymbol{x}, t) - g(t)^2 \nabla_{\boldsymbol{x}} \log p_t(\boldsymbol{x}) \right] dt + g(t) \, d\bar{\boldsymbol{w}},
\]</span></p>
<p>where <span class="math inline">\(\bar{\boldsymbol{w}}\)</span> is a standard Wiener process when time flows backwards. Note that <span class="math inline">\(dt\)</span> in this equation is negative, as we are propagating from <span class="math inline">\(t = 1\)</span> to <span class="math inline">\(t = 0\)</span>. If we do not know <span class="math inline">\(\nabla_{\boldsymbol{x}} \log p_t(\boldsymbol{x})\)</span>, which is also known as the <strong>score</strong> function, we can approximate it using a Neural Network.</p>
<p>There are many possible choices for the functions <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x}, t)\)</span> and <span class="math inline">\(g(t)\)</span>, but we choose <span class="math inline">\(\boldsymbol{f}(\boldsymbol{x}, t) = -\frac{1}{2} \beta(t) \boldsymbol{x}(t)\)</span> and <span class="math inline">\(g(t) = \sqrt{\beta(t)}\)</span>. We can show that a discretization of the SDE (this particular SDE is known as the VP-SDE) is equivalent to the Markov Chain formulation of the Diffusion Models. In this case, we have the following forward SDE:</p>
<p><span class="math display">\[
d\boldsymbol{x} = -\frac{1}{2} \beta(t) \boldsymbol{x}(t) \, dt + \sqrt{\beta(t)} \, d\boldsymbol{w},
\]</span></p>
<p>which can be reversed by:</p>
<p><span class="math display">\[
d\boldsymbol{x} = \left[ -\frac{1}{2} \beta(t) \boldsymbol{x}(t) - \beta(t) \nabla_{\boldsymbol{x}} \log p_t(\boldsymbol{x}) \right] dt + \sqrt{\beta(t)} \, d\bar{\boldsymbol{w}}.
\]</span></p>
<p>For the two formulations to be “equivalent,” we need to set <span class="math inline">\(\beta(t) := \bar{\beta}_{t+\Delta t} := N \beta_{tN+1}\)</span> at the points of discretization. If we use the same hyperparameters as above and discretize the SDE at the same points as the Markov Chain, then we get the following discretization of <span class="math inline">\(\bar{\beta}_t\)</span>:</p>
<p><span class="math display">\[
\begin{align*}
    \bar{\beta}_1 &amp;= 0.1, \\
    \bar{\beta}_T &amp;= 20, \\
    \bar{\beta}_t &amp;= \bar{\beta}_{t-1} + \frac{\bar{\beta}_N - \bar{\beta}_1}{N}, \quad \text{for } t=2, \ldots, N-1  
\end{align*}
\]</span></p>
</section>
<section id="understanding-sdes" class="level2">
<h2 class="anchored" data-anchor-id="understanding-sdes">Understanding SDEs</h2>
<p>To build an intuitive understanding of stochastic differential equations, it helps to get our hands dirty with a straightforward numerical experiment. The idea is to think of an SDE as describing a continuous-time process that evolves with both a deterministic trend (the “drift”) and a random “noise” component that keeps shaking things up as time goes by. This might sound abstract, but we can make it more concrete by actually simulating a path of a simple SDE using the simplest and most intuitive method: the Euler–Maruyama method. To simulate the forward diffusion using the VP-SDE we have formulated above, we do the following:</p>
<ol type="1">
<li>Set the timestep <span class="math inline">\(\Delta t = 1/N = 0.001\)</span>.</li>
<li>Take a sample <span class="math inline">\(\boldsymbol{x}_0\)</span> from our dataset.</li>
<li>For <span class="math inline">\(t = \Delta t, 2\Delta t, \ldots, 1\)</span> do
<ul>
<li>Set <span class="math inline">\(\boldsymbol{x}_{t} = \boldsymbol{x}_{t-\Delta t} - \frac{1}{2} \bar{\beta}_t \boldsymbol{x}_{t-\Delta t} \Delta t + \sqrt{\bar{\beta}_t \Delta t} \boldsymbol{z}_{t-\Delta t}\)</span> where <span class="math inline">\(\boldsymbol{z}_{t-\Delta t} \sim \mathcal{N}(0, I)\)</span>.</li>
</ul></li>
</ol>
<p>To reverse this process (i.e., generate samples that could exist in our dataset):</p>
<ol type="1">
<li>Sample <span class="math inline">\(\boldsymbol{x}_1 \sim \mathcal{N}(0, I)\)</span> from our dataset.</li>
<li>For <span class="math inline">\(t = 1, (1 - \Delta t), (1 - 2\Delta t), \ldots, \Delta t\)</span> do
<ul>
<li>Set <span class="math inline">\(\boldsymbol{x}_{t} = \boldsymbol{x}_{t+\Delta t} + \left[ \frac{1}{2} \bar{\beta}_{t} \boldsymbol{x}_{t+\Delta t} + \bar{\beta}_{t} \nabla_{\boldsymbol{x}} \log p_{t+\Delta t}(\boldsymbol{x}_{t+\Delta t}) \right] \Delta t + \sqrt{\bar{\beta}_{t} \Delta t} \, \boldsymbol{z}_{t+\Delta t},\)</span> where <span class="math inline">\(\boldsymbol{z}_{t+\Delta t} \sim \mathcal{N}(0, I)\)</span>.</li>
</ul></li>
</ol>
</section>
<section id="showing-the-equivalence" class="level2">
<h2 class="anchored" data-anchor-id="showing-the-equivalence">Showing the equivalence</h2>
<p>To show that a discretisation of the SDE is equivalent to the Markov Chain (which is also shown in the appendix of <span class="citation" data-cites="sde_diff">(<a href="#ref-sde_diff" role="doc-biblioref">Song et al. 2021</a>)</span>), we first show that the forward processes are equivalent and then that the reverse processes are equivalent as <span class="math inline">\(\Delta t \to 0\)</span> (which is equivalent to <span class="math inline">\(N \to \infty\)</span>).</p>
<section id="equivalence-of-forward-processes" class="level3">
<h3 class="anchored" data-anchor-id="equivalence-of-forward-processes">Equivalence of Forward Processes</h3>
<p>We need to show that:</p>
<p><span class="math display">\[
\boldsymbol{x}_t = \sqrt{1 - \beta_t} \, \boldsymbol{x}_{t-1} + \sqrt{\beta_t} \, \boldsymbol{z}_{t-1} \iff \boldsymbol{x}_{t} = \boldsymbol{x}_{t-1} - \frac{1}{2} \bar{\beta}_t \boldsymbol{x}_{t-1} \Delta t + \sqrt{\bar{\beta}_t \Delta t} \, \boldsymbol{z}_{t-1},
\tag{1} \label{eq:equiv_1}
\]</span></p>
<p>as <span class="math inline">\(\Delta t \to 0\)</span>, where we use <span class="math inline">\(\boldsymbol{x}_{t-1}\)</span> rather than <span class="math inline">\(\boldsymbol{x}_{t-\Delta t}\)</span> for notational convenience. To show that the equivalence holds, we use the Taylor approximation of <span class="math inline">\(f(x) = \sqrt{1 - x}\)</span> around <span class="math inline">\(x = 0\)</span>:</p>
<p><span class="math display">\[
\sqrt{1 - x} = 1 - \frac{x}{2} - \frac{x^2}{8} - \ldots
\]</span></p>
<p>If we set <span class="math inline">\(x = \bar{\beta}_t \Delta t\)</span>, we have:</p>
<p><span class="math display">\[
\sqrt{1 - \bar{\beta}_t \Delta t} = 1 - \frac{\bar{\beta}_t \Delta t}{2} - \frac{\bar{\beta}_t \Delta t^2}{8} - \ldots
\]</span></p>
<p>and as <span class="math inline">\(\Delta t\)</span> approaches 0, the approximation <span class="math inline">\(\sqrt{1 - \bar{\beta}_t \Delta t} \approx 1 - \frac{\bar{\beta}_t \Delta t}{2}\)</span> improves. Then, starting from the left-hand side of Equivalence (<span class="math inline">\(\ref{eq:equiv_1}\)</span>):</p>
<p><span class="math display">\[
\begin{align*}
    \boldsymbol{x}_t &amp;= \sqrt{1 - \beta_t} \, \boldsymbol{x}_{t-1} + \sqrt{\beta_t} \, \boldsymbol{z}_{t-1} \\
    \iff \boldsymbol{x}_t &amp;= \sqrt{1 - \bar{\beta}_t \Delta t} \, \boldsymbol{x}_{t-1} + \sqrt{\bar{\beta}_t \Delta t} \, \boldsymbol{z}_{t-1} \quad \text{by the definition of } \bar{\beta}_t \\
    \iff \boldsymbol{x}_t &amp;= \left(1 - \frac{\bar{\beta}_t \Delta t}{2}\right) \boldsymbol{x}_{t-1} + \sqrt{\bar{\beta}_t \Delta t} \, \boldsymbol{z}_{t-1} \quad \text{as } \Delta t \to 0 \\
    \iff \boldsymbol{x}_{t} &amp;= \boldsymbol{x}_{t-1} - \frac{1}{2} \bar{\beta}_t \boldsymbol{x}_{t-1} \Delta t + \sqrt{\bar{\beta}_t \Delta t} \, \boldsymbol{z}_{t-1}    
\end{align*}
\]</span></p>
</section>
<section id="equivalence-of-reverse-processes" class="level3">
<h3 class="anchored" data-anchor-id="equivalence-of-reverse-processes">Equivalence of Reverse Processes</h3>
<p>We need to show that:</p>
<p><span class="math display">\[
    \boldsymbol{x}_t=\frac{1}{\sqrt{1-\beta_t}}\left(\boldsymbol{x}_{t+1}-\frac{\beta_t}{\sqrt{1-\bar{\alpha}_t}}\hat{\epsilon}(\boldsymbol{x}_{t+1},t+1)\right) \iff \boldsymbol{x}_{t} = \boldsymbol{x}_{t+1} + \left[\frac{1}{2}\bar{\beta}_{t} \boldsymbol{x}_{t+1} + \bar{\beta}_{t}\nabla_{\boldsymbol{x}}\log p_{t+1}(\boldsymbol{x}_{t+1})\right]\Delta t,
\tag{2} \label{eq:equiv_2}
\]</span></p>
<p>as <span class="math inline">\(\Delta t \to 0\)</span> where we use <span class="math inline">\(\boldsymbol{x}_{t+1}\)</span> rather than <span class="math inline">\(\boldsymbol{x}_{t+\Delta t}\)</span> for notational convenience and have omitted the noise terms for brevity (as we have already shown their equivalence in the previous section). To show that the equivalence holds we use the Taylor approximation of <span class="math inline">\(g(x)=\frac{1}{\sqrt{1-x}}\)</span> around <span class="math inline">\(x=0\)</span>:</p>
<p><span class="math display">\[\frac{1}{\sqrt{1-x}}=1+\frac{x}{2}+\frac{3x^2}{8}+...\]</span></p>
<p>If we set <span class="math inline">\(x=\bar{\beta_t}\Delta t\)</span> we have:</p>
<p><span class="math display">\[\frac{1}{\sqrt{1-\bar{\beta_t}\Delta t}}=1+\frac{\bar{\beta_t}\Delta t}{2}+\frac{3\bar{\beta_t}\Delta t^2}{8}+...\]</span></p>
<p>and as <span class="math inline">\(\Delta t\)</span> approaches 0 the approximation <span class="math inline">\(\frac{1}{\sqrt{1-\bar{\beta_t\Delta t}}}\approx 1+\frac{\bar{\beta_t}\Delta t}{2}\)</span> improves. Then, starting from the left hand side of equivalence (<span class="math inline">\(\ref{eq:equiv_2}\)</span>):</p>
<p><span class="math display">\[
\begin{align*}
\boldsymbol{x}_t&amp;=\frac{1}{\sqrt{1-\beta_t}}\left(\boldsymbol{x}_{t+1}-\frac{\beta_t}{\sqrt{1-\bar{\alpha}_t}}\hat{\epsilon}(\boldsymbol{x}_{t+1},t+1)\right) \\
\iff \boldsymbol{x}_t &amp;=\frac{1}{\sqrt{1-\bar{\beta}_t\Delta t}}\left(\boldsymbol{x}_{t+1}-\frac{\bar{\beta}_t\Delta t}{\sqrt{1-\bar{\alpha}_t}}\hat{\epsilon}(\boldsymbol{x}_{t+1},t+1)\right), \text{ by the definition of } \bar{\beta}_t \\
\iff \boldsymbol{x}_t &amp;= \left(1+\frac{\bar{\beta_t}\Delta t}{2}\right)\left(\boldsymbol{x}_{t+1}-\frac{\bar{\beta}_t\Delta t}{\sqrt{1-\bar{\alpha}_t}}\hat{\epsilon}(\boldsymbol{x}_{t+1},t+1)\right), \text{ as } \Delta t \to 0 \\
\iff \boldsymbol{x}_t &amp;= \boldsymbol{x}_{t+1} + \frac{\bar{\beta}_t \Delta t}{2} \boldsymbol{x}_{t+1} - \frac{\bar{\beta}_t \Delta t}{\sqrt{1 - \bar{\alpha}_t}} \hat{\epsilon}(\boldsymbol{x}_{t+1}, t+1) - \frac{(\bar{\beta}_t \Delta t)^2}{2 \sqrt{1 - \bar{\alpha}_t}} \hat{\epsilon}(\boldsymbol{x}_{t+1}, t+1) \\
\iff \boldsymbol{x}_t &amp;= \boldsymbol{x}_{t+1} + \frac{\bar{\beta}_t \Delta t}{2} \boldsymbol{x}_{t+1} - \frac{\bar{\beta}_t \Delta t}{\sqrt{1 - \bar{\alpha}_t}} \hat{\epsilon}(\boldsymbol{x}_{t+1}, t+1)\\
\iff \boldsymbol{x}_t &amp;= \boldsymbol{x}_{t+1} + \left(\frac{1}{2}\bar{\beta}_t\boldsymbol{x}_{t+1}-\bar{\beta}_t\frac{\hat{\epsilon}(\boldsymbol{x}_{t+1}, t+1)}{\sqrt{1 - \bar{\alpha}_t}} \right)\Delta t
\end{align*}
\]</span></p>
<p>Therefore, when the Neural Network that estimates the noise is:</p>
<p><span class="math display">\[\hat{\epsilon}(\boldsymbol{x}_{t+1}, t+1)=-\sqrt{1 - \bar{\alpha}_t}\nabla_{\boldsymbol{x}}\log p_{t+1}(\boldsymbol{x}_{t+1}),\]</span></p>
<p>the discretisation of the reverse diffusion of the SDE is equivalent to the reverse Markov Chain. In practise, we train neural networks for each of the two formulations and can divide the neural network of the DDPM model by <span class="math inline">\(-\sqrt{1 - \bar{\alpha}_t}\)</span> to obtain an approximation of the score function.</p>



</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-sora" class="csl-entry" role="listitem">
Brooks, Tim, Bill Peebles, Connor Holmes, Will DePue, Yufei Guo, Li Jing, David Schnurr, et al. 2024. <span>“Video Generation Models as World Simulators.”</span> <a href="https://openai.com/research/video-generation-models-as-world-simulators">https://openai.com/research/video-generation-models-as-world-simulators</a>.
</div>
<div id="ref-ddpm" class="csl-entry" role="listitem">
Ho, Jonathan, Ajay Jain, and Pieter Abbeel. 2020. <span>“Denoising Diffusion Probabilistic Models.”</span> <a href="https://arxiv.org/abs/2006.11239">https://arxiv.org/abs/2006.11239</a>.
</div>
<div id="ref-latent_diff" class="csl-entry" role="listitem">
Rombach, Robin, Andreas Blattmann, Dominik Lorenz, Patrick Esser, and Björn Ommer. 2022. <span>“High-Resolution Image Synthesis with Latent Diffusion Models.”</span> <a href="https://arxiv.org/abs/2112.10752">https://arxiv.org/abs/2112.10752</a>.
</div>
<div id="ref-sde_diff" class="csl-entry" role="listitem">
Song, Yang, Jascha Sohl-Dickstein, Diederik P. Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. 2021. <span>“Score-Based Generative Modeling Through Stochastic Differential Equations.”</span> <a href="https://arxiv.org/abs/2011.13456">https://arxiv.org/abs/2011.13456</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/zedt123\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>